<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{PAGE_TITLE}}</title>
    <style>
        :root {
            --primary: {{PRIMARY_COLOR}};
            --primary-dark: color-mix(in srgb, var(--primary) 80%, black);
            --bg: #0f0f0f;
            --surface: #1a1a1a;
            --surface-hover: #252525;
            --text: #e5e5e5;
            --text-muted: #888;
            --border: #333;
            --success: #22c55e;
            --error: #ef4444;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
        }
        .container {
            max-width: 480px;
            width: 100%;
        }
        h1 {
            font-size: 1.75rem;
            margin-bottom: 0.5rem;
            text-align: center;
        }
        h2 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
        }
        .subtitle {
            color: var(--text-muted);
            text-align: center;
            margin-bottom: 2rem;
        }
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }
        .step {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .step:last-child { margin-bottom: 0; }
        .step-number {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.875rem;
            flex-shrink: 0;
        }
        .step-number.done {
            background: var(--success);
        }
        .step-number.error {
            background: var(--error);
        }
        .step-content { flex: 1; }
        .step-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }
        .step-desc {
            color: var(--text-muted);
            font-size: 0.875rem;
        }
        button {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
            width: 100%;
        }
        button:hover:not(:disabled) {
            background: var(--primary-dark);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-secondary {
            background: var(--surface-hover);
            border: 1px solid var(--border);
        }
        .btn-secondary:hover:not(:disabled) {
            background: var(--border);
        }
        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            width: auto;
        }
        input, select, textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg);
            color: var(--text);
            font-size: 1rem;
            margin-bottom: 0.75rem;
        }
        textarea {
            font-family: monospace;
            font-size: 0.875rem;
            resize: vertical;
            min-height: 80px;
        }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary);
        }
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        .form-group { margin-bottom: 1rem; }
        .wallet-address {
            font-family: monospace;
            font-size: 0.875rem;
            background: var(--bg);
            padding: 0.5rem;
            border-radius: 6px;
            word-break: break-all;
        }
        .status {
            padding: 0.75rem;
            border-radius: 8px;
            margin-top: 1rem;
            font-size: 0.875rem;
        }
        .status.success {
            background: color-mix(in srgb, var(--success) 20%, transparent);
            border: 1px solid var(--success);
        }
        .status.error {
            background: color-mix(in srgb, var(--error) 20%, transparent);
            border: 1px solid var(--error);
        }
        .status.info {
            background: color-mix(in srgb, var(--primary) 20%, transparent);
            border: 1px solid var(--primary);
        }
        .hidden { display: none !important; }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 0.5rem;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .tx-link {
            color: var(--primary);
            text-decoration: none;
        }
        .tx-link:hover {
            text-decoration: underline;
        }
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .tab {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg);
            color: var(--text-muted);
            cursor: pointer;
            text-align: center;
            font-size: 0.875rem;
        }
        .tab.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        .tab:hover:not(.active) {
            background: var(--surface-hover);
        }
        .server-card {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
        }
        .server-card:hover {
            border-color: var(--primary);
        }
        .server-card.selected {
            border-color: var(--primary);
            background: color-mix(in srgb, var(--primary) 10%, var(--bg));
        }
        .server-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .server-card-title {
            font-weight: 600;
        }
        .server-card-id {
            color: var(--text-muted);
            font-size: 0.875rem;
        }
        .connection-info {
            background: var(--bg);
            border: 1px solid var(--success);
            border-radius: 8px;
            padding: 1rem;
            font-family: monospace;
            font-size: 0.875rem;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .code-block {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            font-family: monospace;
            font-size: 0.75rem;
            white-space: pre-wrap;
            word-break: break-all;
            margin-bottom: 0.75rem;
        }
        .divider {
            border-top: 1px solid var(--border);
            margin: 2rem 0;
        }
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            text-align: center;
        }
        .section-subtitle {
            color: var(--text-muted);
            text-align: center;
            margin-bottom: 1.5rem;
            font-size: 0.875rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>{{PAGE_TITLE}}</h1>
        <p class="subtitle">Get your own server with web3 authentication</p>

        <!-- Step 1: Connect Wallet -->
        <div class="card" id="step1">
            <div class="step">
                <div class="step-number" id="step1-num">1</div>
                <div class="step-content">
                    <div class="step-title">Connect Wallet</div>
                    <div class="step-desc">Connect your OPNet wallet to get started</div>
                </div>
            </div>
            <div id="wallet-not-connected">
                <button id="btn-connect">Connect OPWallet</button>
            </div>
            <div id="wallet-connected" class="hidden">
                <div class="wallet-address" id="wallet-address"></div>
            </div>
        </div>

        <!-- Step 2: Sign Message (hidden from user - automatic) -->
        <div class="card" id="step2">
            <div class="step">
                <div class="step-number" id="step2-num">2</div>
                <div class="step-content">
                    <div class="step-title">Authenticate</div>
                    <div class="step-desc">Sign a message to create your secure access credentials</div>
                </div>
            </div>
            <button id="btn-sign" disabled>Sign Authentication</button>
            <div id="signature-status"></div>
        </div>

        <!-- Step 3: Configure & Purchase -->
        <div class="card" id="step3">
            <div class="step">
                <div class="step-number" id="step3-num">3</div>
                <div class="step-content">
                    <div class="step-title">Purchase Subscription</div>
                    <div class="step-desc">Choose your plan and complete the purchase</div>
                </div>
            </div>
            <div class="form-group">
                <label for="plan-select">Plan</label>
                <select id="plan-select" disabled>
                    <option value="">Loading plans...</option>
                </select>
            </div>
            <div class="form-group">
                <label for="days-input">Duration (days)</label>
                <input type="number" id="days-input" value="30" min="1" max="365" disabled>
            </div>
            <div class="form-group">
                <label>Total Cost</label>
                <div id="total-cost" style="font-size: 1.25rem; font-weight: 600;">-</div>
            </div>
            <button id="btn-purchase" disabled>Purchase Subscription</button>
            <div id="purchase-status"></div>
        </div>

        <!-- Result -->
        <div class="card hidden" id="result-card">
            <div class="step">
                <div class="step-number done">&#x2713;</div>
                <div class="step-content">
                    <div class="step-title">Subscription Purchased!</div>
                    <div class="step-desc">Your server is being provisioned</div>
                </div>
            </div>
            <div class="status success">
                <p><strong>Transaction submitted</strong></p>
                <p id="tx-info"></p>
                <p style="margin-top: 0.75rem;">Your server will be ready shortly. You'll receive an NFT with your access credentials.</p>
            </div>
        </div>

        <!-- Divider -->
        <div class="divider"></div>

        <!-- View My Servers Section -->
        <div class="section-title">View My Servers</div>
        <p class="section-subtitle">Decrypt your server connection details from your access NFT</p>

        <div class="card" id="servers-card">
            <div class="tabs">
                <div class="tab active" id="tab-wallet" onclick="switchTab('wallet')">Use Wallet</div>
                <div class="tab" id="tab-offline" onclick="switchTab('offline')">Offline Mode</div>
            </div>

            <!-- Wallet Mode -->
            <div id="mode-wallet">
                <div id="servers-not-connected">
                    <p style="color: var(--text-muted); margin-bottom: 1rem; font-size: 0.875rem;">
                        Connect your wallet above to view your servers
                    </p>
                </div>
                <div id="servers-loading" class="hidden">
                    <p><span class="spinner"></span>Loading your NFTs...</p>
                </div>
                <div id="servers-empty" class="hidden">
                    <p style="color: var(--text-muted); font-size: 0.875rem;">
                        No access NFTs found for your wallet. Purchase a subscription above to get started.
                    </p>
                </div>
                <div id="servers-list" class="hidden"></div>
                <div id="servers-decrypt" class="hidden">
                    <button id="btn-decrypt-wallet">Sign to Decrypt Connection Info</button>
                    <div id="decrypt-wallet-status"></div>
                </div>
                <div id="connection-result" class="hidden">
                    <label>Connection Details</label>
                    <div class="connection-info" id="connection-info"></div>
                </div>
            </div>

            <!-- Offline/Paranoid Mode -->
            <div id="mode-offline" class="hidden">
                <p style="color: var(--text-muted); margin-bottom: 1rem; font-size: 0.875rem;">
                    For users who prefer not to connect a browser wallet. Enter your token ID to look up your NFT.
                </p>

                <div class="form-group">
                    <label for="offline-token-id">Token ID</label>
                    <input type="number" id="offline-token-id" placeholder="e.g., 1" min="0">
                </div>

                <button id="btn-lookup-nft" class="btn-secondary">Lookup NFT</button>
                <div id="offline-lookup-status"></div>

                <div id="offline-nft-info" class="hidden" style="margin-top: 1rem;">
                    <div class="form-group">
                        <label>Message to Sign</label>
                        <div class="code-block" id="offline-public-secret"></div>
                    </div>

                    <div class="form-group">
                        <label>Encrypted Data (hex)</label>
                        <div class="code-block" id="offline-encrypted-data" style="max-height: 100px; overflow-y: auto;"></div>
                    </div>

                    <div class="form-group">
                        <label>Signing Instructions</label>
                        <div class="code-block" id="offline-cli-instructions"></div>
                    </div>

                    <div class="form-group">
                        <label for="offline-signature">Paste Your Schnorr Signature (hex)</label>
                        <textarea id="offline-signature" placeholder="Hex-encoded Schnorr signature..."></textarea>
                    </div>

                    <button id="btn-decrypt-offline">Decrypt Connection Info</button>
                    <div id="decrypt-offline-status"></div>

                    <div id="offline-connection-result" class="hidden" style="margin-top: 1rem;">
                        <label>Connection Details</label>
                        <div class="connection-info" id="offline-connection-info"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Divider -->
        <div class="divider"></div>

        <!-- Send Admin Command Section -->
        <div class="section-title">Send Command</div>
        <p class="section-subtitle">Send authenticated admin commands to the server</p>

        <div class="card" id="admin-command-card">
            <div id="admin-not-connected">
                <p style="color: var(--text-muted); margin-bottom: 1rem; font-size: 0.875rem;">
                    Connect your wallet above to send commands. Only the configured admin wallet can execute commands.
                </p>
            </div>

            <div id="admin-connected" class="hidden">
                <div class="form-group">
                    <label for="command-input">Command</label>
                    <input type="text" id="command-input" placeholder="e.g. letmein 2a01:abcd::243">
                </div>

                <button id="btn-send-command">Sign & Send Command</button>
                <div id="command-status"></div>

                <div id="command-result" class="hidden" style="margin-top: 1rem;">
                    <div class="status success">
                        <p><strong>Command Sent!</strong></p>
                        <p id="command-tx-info"></p>
                        <p style="margin-top: 0.5rem; font-size: 0.875rem;">
                            The server will process this command within the next few blocks.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Noble crypto for ECIES encryption + SHAKE256 key derivation -->
    <!-- OPNet contract interaction (browser build) -->
    <script type="module">
    import { secp256k1 } from 'https://esm.run/@noble/curves@1.4.0/secp256k1';
    import { hkdf } from 'https://esm.run/@noble/hashes@1.4.0/hkdf';
    import { sha256 } from 'https://esm.run/@noble/hashes@1.4.0/sha256';
    import { randomBytes } from 'https://esm.run/@noble/hashes@1.4.0/utils';
    import { shake256 } from 'https://esm.run/@noble/hashes@1.4.0/sha3';
    import {
        JSONRpcProvider, getContract, ABIDataTypes, BitcoinAbiTypes, OP_20_ABI, BitcoinUtils,
    } from 'https://cdn.jsdelivr.net/npm/opnet@1.8.1-beta.13/browser/index.js';

    // ECIES encryption implementation using secp256k1
    window.ECIES = {
        hexToBytes(hex) {
            hex = hex.startsWith('0x') ? hex.slice(2) : hex;
            var bytes = new Uint8Array(hex.length / 2);
            for (var i = 0; i < bytes.length; i++) {
                bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
            }
            return bytes;
        },

        bytesToHex(bytes) {
            return Array.from(bytes).map(function(b) { return b.toString(16).padStart(2, '0'); }).join('');
        },

        async encrypt(publicKeyHex, plaintext) {
            var serverPubKeyBytes = this.hexToBytes(publicKeyHex);
            var ephemeralPrivKey = randomBytes(32);
            var ephemeralPubKey = secp256k1.getPublicKey(ephemeralPrivKey, false);
            var sharedPoint = secp256k1.getSharedSecret(ephemeralPrivKey, serverPubKeyBytes, false);
            var sharedX = sharedPoint.slice(1, 33);
            var encryptionKey = hkdf(sha256, sharedX, new Uint8Array(0), new Uint8Array(0), 32);
            var iv = randomBytes(12);
            var cryptoKey = await crypto.subtle.importKey('raw', encryptionKey, { name: 'AES-GCM' }, false, ['encrypt']);
            var plaintextBytes = new TextEncoder().encode(plaintext);
            var ciphertextWithTag = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, cryptoKey, plaintextBytes);
            var result = new Uint8Array(ephemeralPubKey.length + iv.length + ciphertextWithTag.byteLength);
            result.set(ephemeralPubKey, 0);
            result.set(iv, ephemeralPubKey.length);
            result.set(new Uint8Array(ciphertextWithTag), ephemeralPubKey.length + iv.length);
            return '0x' + this.bytesToHex(result);
        }
    };

    // SHAKE256 key derivation — exposed globally for use in non-module scripts
    window.deriveKey = function(signatureBytes) {
        return shake256(signatureBytes, { dkLen: 32 });
    };

    // OPNet contract interaction — exposed globally
    // Network configs (static — avoids pulling in @btc-vision/bitcoin in browser)
    var NETWORKS = {
        bitcoin:  { messagePrefix: "\x18Bitcoin Signed Message:\n", bech32: "bc",   bech32Opnet: "op",  bip32: { public: 76067358, private: 76066276 }, pubKeyHash: 0,   scriptHash: 5,   wif: 128 },
        testnet:  { messagePrefix: "\x18Bitcoin Signed Message:\n", bech32: "tb",   bech32Opnet: "opt", bip32: { public: 70617039, private: 70615956 }, pubKeyHash: 111, scriptHash: 196, wif: 239 },
        regtest:  { messagePrefix: "\x18Bitcoin Signed Message:\n", bech32: "bcrt", bech32Opnet: "opr", bip32: { public: 70617039, private: 70615956 }, pubKeyHash: 111, scriptHash: 196, wif: 239 },
    };

    function inferNetwork(rpcUrl) {
        if (rpcUrl.includes('mainnet')) return NETWORKS.bitcoin;
        if (rpcUrl.includes('testnet')) return NETWORKS.testnet;
        return NETWORKS.regtest;
    }

    // Contract ABIs
    var ABI = ABIDataTypes;

    var SUBSCRIPTIONS_ABI = [
        { name: 'getTotalPlanCount', type: BitcoinAbiTypes.Function, constant: true,
          inputs: [], outputs: [{ name: 'count', type: ABI.UINT256 }] },
        { name: 'getPlan', type: BitcoinAbiTypes.Function, constant: true,
          inputs: [{ name: 'planId', type: ABI.UINT256 }],
          outputs: [{ name: 'name', type: ABI.STRING }, { name: 'pricePerDay', type: ABI.UINT256 }, { name: 'active', type: ABI.BOOL }] },
        { name: 'buySubscription', type: BitcoinAbiTypes.Function, constant: false,
          inputs: [{ name: 'planId', type: ABI.UINT256 }, { name: 'days', type: ABI.UINT256 }, { name: 'userEncrypted', type: ABI.STRING }],
          outputs: [{ name: 'subscriptionId', type: ABI.UINT256 }] },
    ];

    var NFT_ABI = [
        { name: 'balanceOf', type: BitcoinAbiTypes.Function, constant: true,
          inputs: [{ name: 'owner', type: ABI.ADDRESS }],
          outputs: [{ name: 'balance', type: ABI.UINT256 }] },
        { name: 'ownerOf', type: BitcoinAbiTypes.Function, constant: true,
          inputs: [{ name: 'tokenId', type: ABI.UINT256 }],
          outputs: [{ name: 'owner', type: ABI.ADDRESS }] },
        { name: 'tokenOfOwnerByIndex', type: BitcoinAbiTypes.Function, constant: true,
          inputs: [{ name: 'owner', type: ABI.ADDRESS }, { name: 'index', type: ABI.UINT256 }],
          outputs: [{ name: 'tokenId', type: ABI.UINT256 }] },
        { name: 'getUserEncrypted', type: BitcoinAbiTypes.Function, constant: true,
          inputs: [{ name: 'tokenId', type: ABI.UINT256 }],
          outputs: [{ name: 'userEncrypted', type: ABI.STRING }] },
    ];

    // Shared provider cache (avoids creating multiple providers for the same RPC)
    var _providerCache = {};
    function getProvider(rpcUrl) {
        if (!_providerCache[rpcUrl]) {
            _providerCache[rpcUrl] = new JSONRpcProvider(rpcUrl, inferNetwork(rpcUrl));
        }
        return _providerCache[rpcUrl];
    }

    window.OPNet = {
        getSubscriptionsContract: function(rpcUrl, contractAddress, sender) {
            var provider = getProvider(rpcUrl);
            return getContract(contractAddress, SUBSCRIPTIONS_ABI, provider, provider.network, sender);
        },
        getOP20Contract: function(rpcUrl, tokenAddress, sender) {
            var provider = getProvider(rpcUrl);
            return getContract(tokenAddress, OP_20_ABI, provider, provider.network, sender);
        },
        getNftContract: function(rpcUrl, contractAddress, sender) {
            var provider = getProvider(rpcUrl);
            return getContract(contractAddress, NFT_ABI, provider, provider.network, sender);
        },
        // Resolve a Bitcoin address or contract hex to an OPNet Address object via RPC
        resolveAddress: async function(rpcUrl, address, isContract) {
            var provider = getProvider(rpcUrl);
            return await provider.getPublicKeyInfo(address, !!isContract);
        },
        inferNetwork: inferNetwork,
        expandToDecimals: BitcoinUtils.expandToDecimals.bind(BitcoinUtils),
    };

    console.log('ECIES encryption + SHAKE256 + OPNet contract ready');
    window.dispatchEvent(new Event('ecies-ready'));
    </script>

    <script>
    // Configuration (injected by generator)
    var CONFIG = {
        serverPublicKey: '{{SERVER_PUBLIC_KEY}}',
        publicSecret: '{{PUBLIC_SECRET}}',
        rpcUrl: '{{RPC_URL}}',
        nftContract: '{{NFT_CONTRACT}}',
        subscriptionContract: '{{SUBSCRIPTION_CONTRACT}}',
        paymentToken: '{{PAYMENT_TOKEN}}',
    };

    // Validate OPNet internal address: 0x + 64 hex chars (32 bytes)
    function isValidAddress(addr) {
        return typeof addr === 'string' && /^0x[0-9a-fA-F]{64}$/.test(addr);
    }

    // Convert Uint8Array to base64
    function uint8ToBase64(bytes) {
        var binary = '';
        for (var i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
        return btoa(binary);
    }

    // Convert base64 to Uint8Array
    function base64ToUint8(b64) {
        var binary = atob(b64);
        var bytes = new Uint8Array(binary.length);
        for (var i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        return bytes;
    }

    // Hex string to Uint8Array
    function hexToBytes(hex) {
        hex = hex.startsWith('0x') ? hex.slice(2) : hex;
        var bytes = new Uint8Array(hex.length / 2);
        for (var i = 0; i < bytes.length; i++) {
            bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
        }
        return bytes;
    }

    // AES-GCM decryption
    async function decryptAesGcm(keyBytes, ciphertextHex) {
        ciphertextHex = ciphertextHex.replace(/^0x/, '');
        var data = new Uint8Array(ciphertextHex.length / 2);
        for (var i = 0; i < ciphertextHex.length; i += 2) data[i / 2] = parseInt(ciphertextHex.substr(i, 2), 16);

        var nonce = data.slice(0, 12);
        var ciphertext = data.slice(12);

        var key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-GCM' }, false, ['decrypt']);
        var decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: nonce }, key, ciphertext);
        return new TextDecoder().decode(decrypted);
    }

    // OPWallet detection — window.opnet (NOT window.unisat, that's UniSat)
    // OPWallet extends Unisat interface and adds web3 property with ML-DSA + transaction signing
    function getWallet() {
        if (window.opnet && typeof window.opnet.requestAccounts === 'function') {
            return window.opnet;
        }
        return null;
    }

    // Check if wallet has OPNet web3 provider (ML-DSA, signInteraction)
    function hasWeb3Provider() {
        return wallet && wallet.web3 && typeof wallet.web3.signMLDSAMessage === 'function';
    }

    // State
    var wallet = null;
    var userAddress = null;
    var userSignature = null;       // raw Uint8Array ML-DSA signature
    var encryptedSignature = null;  // ECIES-encrypted base64 of signature
    var plans = [];
    var userNfts = [];
    var selectedNft = null;

    // DOM Elements - Purchase flow
    var btnConnect = document.getElementById('btn-connect');
    var btnSign = document.getElementById('btn-sign');
    var btnPurchase = document.getElementById('btn-purchase');
    var walletNotConnected = document.getElementById('wallet-not-connected');
    var walletConnected = document.getElementById('wallet-connected');
    var walletAddressEl = document.getElementById('wallet-address');
    var daysInput = document.getElementById('days-input');
    var planSelect = document.getElementById('plan-select');
    var totalCostEl = document.getElementById('total-cost');
    var signatureStatus = document.getElementById('signature-status');
    var purchaseStatus = document.getElementById('purchase-status');
    var resultCard = document.getElementById('result-card');

    // Helper: Show status message
    function showStatus(element, message, type) {
        type = type || 'info';
        element.innerHTML = '<div class="status ' + type + '">' + message + '</div>';
    }

    // Helper: Update step indicator
    function updateStep(stepNum, status) {
        var el = document.getElementById('step' + stepNum + '-num');
        el.classList.remove('done', 'error');
        if (status === 'done') {
            el.classList.add('done');
            el.textContent = '\u2713';
        } else if (status === 'error') {
            el.classList.add('error');
            el.textContent = '!';
        } else {
            el.textContent = stepNum;
        }
    }

    // Tab switching for View My Servers
    window.switchTab = function(tab) {
        document.getElementById('tab-wallet').classList.toggle('active', tab === 'wallet');
        document.getElementById('tab-offline').classList.toggle('active', tab === 'offline');
        document.getElementById('mode-wallet').classList.toggle('hidden', tab !== 'wallet');
        document.getElementById('mode-offline').classList.toggle('hidden', tab !== 'offline');
    };

    // Load plans from contract
    async function loadPlans() {
        if (!CONFIG.subscriptionContract) {
            console.warn('Subscription contract not configured');
            return;
        }

        // Wait for OPNet module to be ready
        if (!window.OPNet) {
            await new Promise(function(resolve) {
                window.addEventListener('ecies-ready', resolve, { once: true });
            });
        }

        try {
            var contract = window.OPNet.getSubscriptionsContract(CONFIG.rpcUrl, CONFIG.subscriptionContract);
            var countResult = await contract.getTotalPlanCount();
            if ('error' in countResult) {
                throw new Error(countResult.error);
            }
            var totalPlans = Number(countResult.properties.count);
            console.log('Total plans:', totalPlans);

            plans = [];
            planSelect.innerHTML = '';

            for (var i = 1; i <= totalPlans; i++) {
                try {
                    var planResult = await contract.getPlan(BigInt(i));
                    if ('error' in planResult) {
                        console.warn('Error loading plan ' + i + ':', planResult.error);
                        continue;
                    }
                    var p = planResult.properties;
                    if (p.active) {
                        var pricePerDay = Number(p.pricePerDay);
                        plans.push({ id: i, name: p.name, pricePerDay: pricePerDay });
                        var option = document.createElement('option');
                        option.value = i;
                        option.textContent = p.name + ' - ' + pricePerDay + ' tokens/day';
                        planSelect.appendChild(option);
                    }
                } catch (e) {
                    console.warn('Error loading plan ' + i + ':', e);
                }
            }

            if (plans.length === 0) {
                planSelect.innerHTML = '<option value="">No plans available</option>';
            }
        } catch (err) {
            console.error('Error loading plans:', err);
            planSelect.innerHTML = '<option value="">Error loading plans</option>';
        }
    }

    async function loadUserNfts() {
        if (!CONFIG.nftContract || !userAddress) {
            console.warn('NFT contract not configured or wallet not connected');
            return;
        }

        document.getElementById('servers-not-connected').classList.add('hidden');
        document.getElementById('servers-loading').classList.remove('hidden');
        document.getElementById('servers-list').classList.add('hidden');
        document.getElementById('servers-empty').classList.add('hidden');
        document.getElementById('servers-decrypt').classList.add('hidden');
        document.getElementById('connection-result').classList.add('hidden');

        try {
            // Resolve wallet address to OPNet Address object
            var opnetAddr = await window.OPNet.resolveAddress(CONFIG.rpcUrl, userAddress);
            if (!opnetAddr) {
                throw new Error('Could not resolve wallet address');
            }

            var nftContract = window.OPNet.getNftContract(CONFIG.rpcUrl, CONFIG.nftContract, opnetAddr);

            // Get balance
            var balanceResult = await nftContract.balanceOf(opnetAddr);
            var balance = balanceResult.properties?.balance || 0n;
            console.log('NFT balance:', balance.toString());

            if (balance === 0n || balance === 0) {
                document.getElementById('servers-loading').classList.add('hidden');
                document.getElementById('servers-empty').classList.remove('hidden');
                return;
            }

            // Fetch each token
            userNfts = [];
            for (var i = 0n; i < balance; i++) {
                var tokenResult = await nftContract.tokenOfOwnerByIndex(opnetAddr, i);
                var tokenId = tokenResult.properties?.tokenId;
                if (!tokenId && tokenId !== 0n) continue;

                var encResult = await nftContract.getUserEncrypted(tokenId);
                var userEncrypted = encResult.properties?.userEncrypted || '';

                userNfts.push({
                    tokenId: tokenId.toString(),
                    name: 'Server #' + tokenId.toString(),
                    userEncrypted: userEncrypted,
                });
            }

            document.getElementById('servers-loading').classList.add('hidden');

            if (userNfts.length > 0) {
                document.getElementById('servers-list').classList.remove('hidden');
                renderNftList();
            } else {
                document.getElementById('servers-empty').classList.remove('hidden');
            }

        } catch (err) {
            console.error('Error loading NFTs:', err);
            document.getElementById('servers-loading').classList.add('hidden');
            document.getElementById('servers-empty').classList.remove('hidden');
            document.getElementById('servers-empty').innerHTML =
                '<p>Error loading NFTs: ' + (err.message || err) + '</p>';
        }
    }

    // Render NFT list
    function renderNftList() {
        var container = document.getElementById('servers-list');
        container.innerHTML = '';

        userNfts.forEach(function(nft, index) {
            var card = document.createElement('div');
            card.className = 'server-card' + (index === 0 ? ' selected' : '');
            card.innerHTML =
                '<div class="server-card-header">' +
                    '<span class="server-card-title">' + (nft.name || 'Server') + '</span>' +
                    '<span class="server-card-id">Token #' + nft.tokenId + '</span>' +
                '</div>';
            card.onclick = function() { selectNft(index); };
            container.appendChild(card);
        });

        if (userNfts.length > 0) {
            selectNft(0);
        }
    }

    // Select an NFT
    function selectNft(index) {
        selectedNft = userNfts[index];
        document.querySelectorAll('.server-card').forEach(function(card, i) {
            card.classList.toggle('selected', i === index);
        });
        document.getElementById('servers-decrypt').classList.remove('hidden');
        document.getElementById('connection-result').classList.add('hidden');
        document.getElementById('decrypt-wallet-status').innerHTML = '';
    }

    // Decrypt NFT connection info (wallet mode)
    document.getElementById('btn-decrypt-wallet').addEventListener('click', async function() {
        if (!selectedNft || !wallet) return;

        var btn = document.getElementById('btn-decrypt-wallet');
        var statusEl = document.getElementById('decrypt-wallet-status');

        try {
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span>Signing...';

            // userEncrypted from the NFT (fetched during loadUserNfts)
            var userEncrypted = selectedNft.userEncrypted;

            if (!userEncrypted) {
                throw new Error('No encrypted data found in NFT');
            }

            // Sign the public secret with Schnorr via OPWallet
            var sigResult = await wallet.signMessage(CONFIG.publicSecret, 'schnorr');

            // Derive symmetric key from Schnorr signature using SHAKE256
            showStatus(statusEl, 'Decrypting...', 'info');

            // Wait for SHAKE256 to be ready
            if (!window.deriveKey) {
                await new Promise(function(resolve) {
                    window.addEventListener('ecies-ready', resolve, { once: true });
                });
            }

            var sigBytes = typeof sigResult === 'string' ? hexToBytes(sigResult) : new Uint8Array(sigResult);
            var keyBytes = window.deriveKey(sigBytes);

            // Decrypt
            var decrypted = await decryptAesGcm(keyBytes, userEncrypted);

            // Show result
            document.getElementById('connection-info').textContent = decrypted;
            document.getElementById('connection-result').classList.remove('hidden');
            statusEl.innerHTML = '';

        } catch (err) {
            console.error('Decrypt error:', err);
            showStatus(statusEl, err.message || 'Decryption failed', 'error');
        } finally {
            btn.disabled = false;
            btn.textContent = 'Sign to Decrypt Connection Info';
        }
    });

    document.getElementById('btn-lookup-nft').addEventListener('click', async function() {
        var statusEl = document.getElementById('offline-lookup-status');
        var btn = document.getElementById('btn-lookup-nft');

        if (!CONFIG.nftContract) {
            showStatus(statusEl, 'NFT contract not configured', 'error');
            return;
        }

        var tokenId = document.getElementById('offline-token-id').value;
        if (!tokenId) {
            showStatus(statusEl, 'Please enter a token ID', 'error');
            return;
        }

        try {
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span>Looking up...';
            showStatus(statusEl, 'Querying NFT contract...', 'info');

            var nftContract = window.OPNet.getNftContract(CONFIG.rpcUrl, CONFIG.nftContract);

            var encResult = await nftContract.getUserEncrypted(BigInt(tokenId));
            var userEncrypted = encResult.properties?.userEncrypted || '';

            if (!userEncrypted) {
                showStatus(statusEl, 'No encrypted data found for token #' + tokenId, 'error');
                return;
            }

            window.offlineNftData = { tokenId: tokenId, userEncrypted: userEncrypted };

            showStatus(statusEl,
                'Found encrypted data for token #' + tokenId + ' (' + userEncrypted.length + ' chars).', 'success');

            // Populate the offline info fields
            document.getElementById('offline-public-secret').textContent = CONFIG.publicSecret;
            document.getElementById('offline-encrypted-data').textContent = userEncrypted;
            document.getElementById('offline-cli-instructions').innerHTML =
                'Sign the message above using Schnorr (not ML-DSA) and paste the hex signature below.<br><br>' +
                '<code>npm install @noble/curves</code><br><br>' +
                '<code>node -e "const {schnorr}=require(\'@noble/curves/secp256k1\');\n' +
                'const msg=Buffer.from(\'' + CONFIG.publicSecret + '\');\n' +
                'const sig=schnorr.sign(msg, \'YOUR_PRIVATE_KEY_HEX\');\n' +
                'console.log(Buffer.from(sig).toString(\'hex\'));"</code>';
            document.getElementById('offline-nft-info').classList.remove('hidden');

        } catch (err) {
            console.error('NFT lookup error:', err);
            showStatus(statusEl, 'Lookup failed: ' + (err.message || err), 'error');
        } finally {
            btn.disabled = false;
            btn.textContent = 'Lookup NFT';
        }
    });

    // Decrypt (offline mode)
    document.getElementById('btn-decrypt-offline').addEventListener('click', async function() {
        var statusEl = document.getElementById('decrypt-offline-status');
        var signatureInput = document.getElementById('offline-signature').value.trim();

        if (!signatureInput) {
            showStatus(statusEl, 'Please paste your Schnorr signature (hex)', 'error');
            return;
        }

        if (!window.offlineNftData) {
            showStatus(statusEl, 'Please lookup an NFT first', 'error');
            return;
        }

        try {
            showStatus(statusEl, 'Decrypting...', 'info');

            // Wait for SHAKE256 to be ready
            if (!window.deriveKey) {
                await new Promise(function(resolve) {
                    window.addEventListener('ecies-ready', resolve, { once: true });
                });
            }

            // Decode hex signature to Uint8Array, then derive key via SHAKE256
            var sigBytes = hexToBytes(signatureInput);
            var keyBytes = window.deriveKey(sigBytes);
            var decrypted = await decryptAesGcm(keyBytes, window.offlineNftData.userEncrypted);

            document.getElementById('offline-connection-info').textContent = decrypted;
            document.getElementById('offline-connection-result').classList.remove('hidden');
            statusEl.innerHTML = '';

        } catch (err) {
            console.error('Decrypt error:', err);
            showStatus(statusEl, 'Decryption failed. Make sure you signed the correct message with the correct key.', 'error');
        }
    });

    // Step 1: Connect OPWallet
    btnConnect.addEventListener('click', async function() {
        try {
            btnConnect.disabled = true;
            btnConnect.innerHTML = '<span class="spinner"></span>Connecting...';

            wallet = getWallet();
            if (!wallet) {
                throw new Error('No OPWallet found. Install the OPWallet browser extension.');
            }

            var accounts = await wallet.requestAccounts();
            if (!accounts || !accounts.length) {
                throw new Error('No accounts returned from OPWallet');
            }

            userAddress = accounts[0];

            walletNotConnected.classList.add('hidden');
            walletConnected.classList.remove('hidden');
            walletAddressEl.textContent = userAddress;
            updateStep(1, 'done');
            btnSign.disabled = false;

            // Load user's NFTs for View My Servers
            loadUserNfts();

            // Show admin command section
            document.getElementById('admin-not-connected').classList.add('hidden');
            document.getElementById('admin-connected').classList.remove('hidden');

        } catch (err) {
            showStatus(signatureStatus, err.message, 'error');
            updateStep(1, 'error');
            btnConnect.disabled = false;
            btnConnect.textContent = 'Connect OPWallet';
        }
    });

    // Step 2: Sign Message (ML-DSA via OPWallet)
    btnSign.addEventListener('click', async function() {
        try {
            btnSign.disabled = true;
            btnSign.innerHTML = '<span class="spinner"></span>Waiting for signature...';

            if (!wallet) {
                throw new Error('Wallet not connected');
            }

            // Wait for ECIES module to be ready
            if (!window.ECIES) {
                await new Promise(function(resolve) {
                    window.addEventListener('ecies-ready', resolve, { once: true });
                });
            }

            // Sign the public secret with Schnorr via OPWallet
            var sigResult = await wallet.signMessage(CONFIG.publicSecret, 'schnorr');
            userSignature = typeof sigResult === 'string' ? hexToBytes(sigResult) : new Uint8Array(sigResult);

            // Encrypt the signature for the server (ECIES with server's secp256k1 key)
            showStatus(signatureStatus, 'Encrypting credentials...', 'info');
            encryptedSignature = await window.ECIES.encrypt(CONFIG.serverPublicKey, sigResult);

            showStatus(signatureStatus, 'Authentication complete!', 'success');
            updateStep(2, 'done');

            planSelect.disabled = false;
            daysInput.disabled = false;
            btnPurchase.disabled = false;
            updateCost();

        } catch (err) {
            console.error('Sign error:', err);
            showStatus(signatureStatus, err.message, 'error');
            updateStep(2, 'error');
            btnSign.disabled = false;
            btnSign.textContent = 'Sign Authentication';
        }
    });

    // Update cost calculation
    // TODO: When contract interaction is available, use contract.calculatePayment() or local math
    async function updateCost() {
        var planId = parseInt(planSelect.value);
        var days = parseInt(daysInput.value) || 30;
        var plan = plans.find(function(p) { return p.id === planId; });
        if (plan) {
            // Prices are in token units per day (not USD)
            var total = days * plan.pricePerDay;
            totalCostEl.textContent = total + ' tokens';
        } else {
            totalCostEl.textContent = '-';
        }
    }

    daysInput.addEventListener('input', updateCost);
    planSelect.addEventListener('change', updateCost);

    // Step 3: Purchase
    btnPurchase.addEventListener('click', async function() {
        try {
            btnPurchase.disabled = true;
            btnPurchase.innerHTML = '<span class="spinner"></span>Processing...';

            var planId = parseInt(planSelect.value);
            var days = parseInt(daysInput.value);

            if (!CONFIG.subscriptionContract || !CONFIG.paymentToken) {
                throw new Error('Contract addresses not configured');
            }

            if (!planId || planId < 1) {
                throw new Error('Please select a plan');
            }

            if (!days || days < 1) {
                throw new Error('Please enter number of days');
            }

            if (!encryptedSignature) {
                throw new Error('Please complete authentication first (Step 2)');
            }

            if (!userAddress) {
                throw new Error('Wallet not connected');
            }

            // Calculate payment amount locally (price is in token units per day)
            var plan = plans.find(function(p) { return p.id === planId; });
            if (!plan) {
                throw new Error('Selected plan not found');
            }
            var totalCostHuman = BigInt(days) * BigInt(plan.pricePerDay);
            showStatus(purchaseStatus, 'Total cost: ' + totalCostHuman.toString() + ' tokens. Resolving address...', 'info');

            // Resolve bc1p Bitcoin address to OPNet Address object
            var opnetAddress = await window.OPNet.resolveAddress(CONFIG.rpcUrl, userAddress);
            if (!opnetAddress) {
                throw new Error('Could not resolve wallet address. Make sure your address is indexed on OPNet.');
            }
            console.log('Resolved OPNet address:', opnetAddress.toHex());

            // Get OP20 token contract (with sender Address for transaction context)
            var tokenContract = window.OPNet.getOP20Contract(CONFIG.rpcUrl, CONFIG.paymentToken, opnetAddress);

            // Get token decimals and expand amount to smallest unit
            var decimalsResult = await tokenContract.decimals();
            if ('error' in decimalsResult) {
                throw new Error('Failed to get token decimals: ' + decimalsResult.error);
            }
            var tokenDecimals = decimalsResult.properties.decimals;
            var totalCost = window.OPNet.expandToDecimals(totalCostHuman.toString(), tokenDecimals);
            console.log('Token decimals:', tokenDecimals, 'Total cost (expanded):', totalCost.toString());

            // Check balance (balanceOf returns amount in smallest unit)
            var balanceResult = await tokenContract.balanceOf(opnetAddress);
            if ('error' in balanceResult) {
                throw new Error('Failed to check balance: ' + balanceResult.error);
            }
            var balance = balanceResult.properties.balance;
            console.log('Token balance:', balance.toString(), 'Required:', totalCost.toString());

            if (balance < totalCost) {
                throw new Error('Insufficient token balance. Have: ' + balance.toString() + ', need: ' + totalCost.toString());
            }

            // Resolve subscription contract address to Address object (required for ABI ADDRESS params)
            var subsAddress = await window.OPNet.resolveAddress(CONFIG.rpcUrl, CONFIG.subscriptionContract, true);
            if (!subsAddress) {
                throw new Error('Could not resolve subscription contract address');
            }

            // Step 1: increaseAllowance for the subscription contract (NOT approve)
            showStatus(purchaseStatus, 'Requesting allowance approval...', 'info');
            var allowanceSim = await tokenContract.increaseAllowance(subsAddress, totalCost);
            if ('error' in allowanceSim) {
                throw new Error('Allowance simulation failed: ' + allowanceSim.error);
            }
            if (allowanceSim.revert) {
                throw new Error('Allowance simulation reverted: ' + allowanceSim.revert);
            }

            console.log('Allowance simulation OK, sending transaction...');
            var network = window.OPNet.inferNetwork(CONFIG.rpcUrl);

            // MotoSwap chaining pattern: approve gets +200 priority fee and +1 fee rate
            // to guarantee it's ordered before the purchase within the same block
            var approveParams = {
                signer: null,
                mldsaSigner: null,
                refundTo: userAddress,
                priorityFee: 200n,
                feeRate: 1,
                maximumAllowedSatToSpend: 10000n,
                network: network,
            };
            var allowanceTx = await allowanceSim.sendTransaction(approveParams);
            console.log('Allowance tx:', allowanceTx.transactionId);

            // Step 2: Simulate buySubscription with setAccessList (carries state forward for simulation)
            var subsContract = window.OPNet.getSubscriptionsContract(CONFIG.rpcUrl, CONFIG.subscriptionContract, opnetAddress);
            subsContract.setAccessList(allowanceSim.accessList);

            var buySim = await subsContract.buySubscription(BigInt(planId), BigInt(days), encryptedSignature);
            if ('error' in buySim) {
                throw new Error('Purchase simulation failed: ' + buySim.error);
            }
            if (buySim.revert) {
                throw new Error('Purchase simulation reverted: ' + buySim.revert);
            }
            console.log('Purchase simulation OK (sub ID:', buySim.properties.subscriptionId.toString() + ')');

            // Step 3: Send purchase immediately — normal priority (lower than approve)
            showStatus(purchaseStatus, 'Sending purchase transaction...', 'info');
            var purchaseParams = {
                signer: null,
                mldsaSigner: null,
                refundTo: userAddress,
                priorityFee: 0n,
                feeRate: 0,
                maximumAllowedSatToSpend: 20000n,
                network: network,
            };
            var buyTx = await buySim.sendTransaction(purchaseParams);
            console.log('Purchase tx:', buyTx.transactionId);

            // Success
            var subId = buySim.properties.subscriptionId;
            showStatus(purchaseStatus, 'Subscription purchased! ID: ' + subId.toString() + ' (tx: ' + buyTx.transactionId.slice(0, 12) + '...)', 'success');
            updateStep(3, 'done');

            // Show result
            resultCard.classList.remove('hidden');
            resultCard.innerHTML =
                '<h2>Subscription Active</h2>' +
                '<p>Plan: ' + plan.name + '</p>' +
                '<p>Duration: ' + days + ' days</p>' +
                '<p>Subscription ID: ' + subId.toString() + '</p>' +
                '<p>Transaction: ' + buyTx.transactionId + '</p>' +
                '<p class="step-desc">Your server will be provisioned shortly. Check back in the "View My Servers" tab once your NFT is minted.</p>';

        } catch (err) {
            console.error(err);
            showStatus(purchaseStatus, err.message || 'Transaction failed', 'error');
            updateStep(3, 'error');
            btnPurchase.disabled = false;
            btnPurchase.textContent = 'Purchase Subscription';
        }
    });

    // Admin Command: HMAC-authenticated command sent via OP_RETURN
    // Format: nonce(3) + " " + command [+ " " + host] + HMAC-SHA256(sharedKey, message)[:16]
    // The shared key is SHAKE256(admin's Schnorr signature of publicSecret)
    // — same key used for NFT userEncrypted. Admin must sign publicSecret first (View My Servers tab).

    // Generate a random 3-char alphanumeric nonce
    var _adminNonce = (function() {
        var chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
        var nonce = '';
        var rand = crypto.getRandomValues(new Uint8Array(3));
        for (var i = 0; i < 3; i++) nonce += chars[rand[i] % chars.length];
        return nonce;
    })();

    document.getElementById('btn-send-command').addEventListener('click', async function() {
        var btn = document.getElementById('btn-send-command');
        var statusEl = document.getElementById('command-status');
        var resultEl = document.getElementById('command-result');

        var commandInput = document.getElementById('command-input').value.trim();

        if (!commandInput) {
            showStatus(statusEl, 'Please enter a command', 'error');
            return;
        }

        if (!wallet) {
            showStatus(statusEl, 'Please connect your wallet first', 'error');
            return;
        }

        try {
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span>Signing...';

            // Build the message: nonce + command (as typed)
            var message = _adminNonce + ' ' + commandInput;

            // Sign publicSecret to derive the shared key (same as decrypt flow)
            showStatus(statusEl, 'Sign the message in OPWallet to authenticate...', 'info');
            var sigResult = await wallet.signMessage(CONFIG.publicSecret, 'schnorr');

            if (!window.deriveKey) {
                await new Promise(function(resolve) {
                    window.addEventListener('ecies-ready', resolve, { once: true });
                });
            }

            var sigBytes = typeof sigResult === 'string' ? hexToBytes(sigResult) : new Uint8Array(sigResult);
            var sharedKey = window.deriveKey(sigBytes);

            // HMAC-SHA256(sharedKey, message), truncated to 16 bytes (128-bit)
            showStatus(statusEl, 'Computing HMAC...', 'info');
            var cryptoKey = await crypto.subtle.importKey(
                'raw', sharedKey, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
            var messageBytes = new TextEncoder().encode(message);
            var hmacFull = await crypto.subtle.sign('HMAC', cryptoKey, messageBytes);
            var hmac16 = new Uint8Array(hmacFull).slice(0, 16);

            // Final payload: message bytes + 16-byte HMAC
            var payload = new Uint8Array(messageBytes.length + 16);
            payload.set(messageBytes, 0);
            payload.set(hmac16, messageBytes.length);

            var payloadHex = Array.from(payload).map(function(b) {
                return b.toString(16).padStart(2, '0');
            }).join('');

            console.log('Admin command payload:', message, '(' + payload.length + ' bytes)');

            // Send as OP_RETURN via OPWallet
            // TODO: OPWallet API for sending a BTC transaction with OP_RETURN data
            // For now, show the hex payload for manual sending
            showStatus(statusEl,
                'Payload ready (' + payload.length + ' bytes). ' +
                'OP_RETURN sending via OPWallet not yet implemented.<br>' +
                '<code style="word-break:break-all;">' + payloadHex + '</code>', 'info');

            // Regenerate nonce for next command
            _adminNonce = (function() {
                var chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
                var nonce = '';
                var rand = crypto.getRandomValues(new Uint8Array(3));
                for (var i = 0; i < 3; i++) nonce += chars[rand[i] % chars.length];
                return nonce;
            })();

        } catch (err) {
            console.error('Command error:', err);
            showStatus(statusEl, err.message || 'Failed to send command', 'error');
        } finally {
            btn.disabled = false;
            btn.textContent = 'Sign & Send Command';
        }
    });

    // Initialize
    console.log('Blockhost Signup Page loaded (OPNet)');
    console.log('Config:', {
        serverPublicKey: CONFIG.serverPublicKey ? CONFIG.serverPublicKey.slice(0, 20) + '...' : 'NOT SET',
        rpcUrl: CONFIG.rpcUrl,
        nftContract: CONFIG.nftContract ? CONFIG.nftContract.slice(0, 20) + '...' : 'NOT SET',
        subscriptionContract: CONFIG.subscriptionContract ? CONFIG.subscriptionContract.slice(0, 20) + '...' : 'NOT SET',
    });

    loadPlans();
    </script>
</body>
</html>
