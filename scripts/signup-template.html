<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{PAGE_TITLE}}</title>
    <style>
        :root {
            --primary: {{PRIMARY_COLOR}};
            --primary-dark: color-mix(in srgb, var(--primary) 80%, black);
            --bg: #0f0f0f;
            --surface: #1a1a1a;
            --surface-hover: #252525;
            --text: #e5e5e5;
            --text-muted: #888;
            --border: #333;
            --success: #22c55e;
            --error: #ef4444;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
        }
        .container {
            max-width: 480px;
            width: 100%;
        }
        h1 {
            font-size: 1.75rem;
            margin-bottom: 0.5rem;
            text-align: center;
        }
        h2 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
        }
        .subtitle {
            color: var(--text-muted);
            text-align: center;
            margin-bottom: 2rem;
        }
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }
        .step {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .step:last-child { margin-bottom: 0; }
        .step-number {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.875rem;
            flex-shrink: 0;
        }
        .step-number.done {
            background: var(--success);
        }
        .step-number.error {
            background: var(--error);
        }
        .step-content { flex: 1; }
        .step-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }
        .step-desc {
            color: var(--text-muted);
            font-size: 0.875rem;
        }
        button {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
            width: 100%;
        }
        button:hover:not(:disabled) {
            background: var(--primary-dark);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-secondary {
            background: var(--surface-hover);
            border: 1px solid var(--border);
        }
        .btn-secondary:hover:not(:disabled) {
            background: var(--border);
        }
        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            width: auto;
        }
        input, select, textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg);
            color: var(--text);
            font-size: 1rem;
            margin-bottom: 0.75rem;
        }
        textarea {
            font-family: monospace;
            font-size: 0.875rem;
            resize: vertical;
            min-height: 80px;
        }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary);
        }
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        .form-group { margin-bottom: 1rem; }
        .wallet-address {
            font-family: monospace;
            font-size: 0.875rem;
            background: var(--bg);
            padding: 0.5rem;
            border-radius: 6px;
            word-break: break-all;
        }
        .status {
            padding: 0.75rem;
            border-radius: 8px;
            margin-top: 1rem;
            font-size: 0.875rem;
        }
        .status.success {
            background: color-mix(in srgb, var(--success) 20%, transparent);
            border: 1px solid var(--success);
        }
        .status.error {
            background: color-mix(in srgb, var(--error) 20%, transparent);
            border: 1px solid var(--error);
        }
        .status.info {
            background: color-mix(in srgb, var(--primary) 20%, transparent);
            border: 1px solid var(--primary);
        }
        .hidden { display: none !important; }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 0.5rem;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .tx-link {
            color: var(--primary);
            text-decoration: none;
        }
        .tx-link:hover {
            text-decoration: underline;
        }
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .tab {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg);
            color: var(--text-muted);
            cursor: pointer;
            text-align: center;
            font-size: 0.875rem;
        }
        .tab.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        .tab:hover:not(.active) {
            background: var(--surface-hover);
        }
        .server-card {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
        }
        .server-card:hover {
            border-color: var(--primary);
        }
        .server-card.selected {
            border-color: var(--primary);
            background: color-mix(in srgb, var(--primary) 10%, var(--bg));
        }
        .server-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .server-card-title {
            font-weight: 600;
        }
        .server-card-id {
            color: var(--text-muted);
            font-size: 0.875rem;
        }
        .connection-info {
            background: var(--bg);
            border: 1px solid var(--success);
            border-radius: 8px;
            padding: 1rem;
            font-family: monospace;
            font-size: 0.875rem;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .code-block {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            font-family: monospace;
            font-size: 0.75rem;
            white-space: pre-wrap;
            word-break: break-all;
            margin-bottom: 0.75rem;
        }
        .divider {
            border-top: 1px solid var(--border);
            margin: 2rem 0;
        }
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            text-align: center;
        }
        .section-subtitle {
            color: var(--text-muted);
            text-align: center;
            margin-bottom: 1.5rem;
            font-size: 0.875rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>{{PAGE_TITLE}}</h1>
        <p class="subtitle">Get your own server with web3 authentication</p>

        <!-- Step 1: Connect Wallet -->
        <div class="card" id="step1">
            <div class="step">
                <div class="step-number" id="step1-num">1</div>
                <div class="step-content">
                    <div class="step-title">Connect Wallet</div>
                    <div class="step-desc">Connect your Ethereum wallet to get started</div>
                </div>
            </div>
            <div id="wallet-not-connected">
                <button id="btn-connect">Connect Wallet</button>
            </div>
            <div id="wallet-connected" class="hidden">
                <div class="wallet-address" id="wallet-address"></div>
            </div>
        </div>

        <!-- Step 2: Sign Message (hidden from user - automatic) -->
        <div class="card" id="step2">
            <div class="step">
                <div class="step-number" id="step2-num">2</div>
                <div class="step-content">
                    <div class="step-title">Authenticate</div>
                    <div class="step-desc">Sign a message to create your secure access credentials</div>
                </div>
            </div>
            <button id="btn-sign" disabled>Sign Authentication</button>
            <div id="signature-status"></div>
        </div>

        <!-- Step 3: Configure & Purchase -->
        <div class="card" id="step3">
            <div class="step">
                <div class="step-number" id="step3-num">3</div>
                <div class="step-content">
                    <div class="step-title">Purchase Subscription</div>
                    <div class="step-desc">Choose your plan and complete the purchase</div>
                </div>
            </div>
            <div class="form-group">
                <label for="plan-select">Plan</label>
                <select id="plan-select" disabled>
                    <option value="">Loading plans...</option>
                </select>
            </div>
            <div class="form-group">
                <label for="days-input">Duration (days)</label>
                <input type="number" id="days-input" value="30" min="1" max="365" disabled>
            </div>
            <div class="form-group">
                <label>Total Cost</label>
                <div id="total-cost" style="font-size: 1.25rem; font-weight: 600;">-</div>
            </div>
            <button id="btn-purchase" disabled>Purchase Subscription</button>
            <div id="purchase-status"></div>
        </div>

        <!-- Result -->
        <div class="card hidden" id="result-card">
            <div class="step">
                <div class="step-number done">✓</div>
                <div class="step-content">
                    <div class="step-title">Subscription Purchased!</div>
                    <div class="step-desc">Your server is being provisioned</div>
                </div>
            </div>
            <div class="status success">
                <p><strong>Transaction:</strong></p>
                <p><a id="tx-link" class="tx-link" href="#" target="_blank"></a></p>
                <p style="margin-top: 0.75rem;">Your server will be ready shortly. You'll receive an NFT with your access credentials.</p>
            </div>
        </div>

        <!-- Divider -->
        <div class="divider"></div>

        <!-- View My Servers Section -->
        <div class="section-title">View My Servers</div>
        <p class="section-subtitle">Decrypt your server connection details from your access NFT</p>

        <div class="card" id="servers-card">
            <div class="tabs">
                <div class="tab active" id="tab-wallet" onclick="switchTab('wallet')">Use Wallet</div>
                <div class="tab" id="tab-offline" onclick="switchTab('offline')">Offline Mode</div>
            </div>

            <!-- Wallet Mode -->
            <div id="mode-wallet">
                <div id="servers-not-connected">
                    <p style="color: var(--text-muted); margin-bottom: 1rem; font-size: 0.875rem;">
                        Connect your wallet above to view your servers
                    </p>
                </div>
                <div id="servers-loading" class="hidden">
                    <p><span class="spinner"></span>Loading your NFTs...</p>
                </div>
                <div id="servers-empty" class="hidden">
                    <p style="color: var(--text-muted); font-size: 0.875rem;">
                        No access NFTs found for your wallet. Purchase a subscription above to get started.
                    </p>
                </div>
                <div id="servers-list" class="hidden"></div>
                <div id="servers-decrypt" class="hidden">
                    <button id="btn-decrypt-wallet">Sign to Decrypt Connection Info</button>
                    <div id="decrypt-wallet-status"></div>
                </div>
                <div id="connection-result" class="hidden">
                    <label>Connection Details</label>
                    <div class="connection-info" id="connection-info"></div>
                </div>
            </div>

            <!-- Offline/Paranoid Mode -->
            <div id="mode-offline" class="hidden">
                <p style="color: var(--text-muted); margin-bottom: 1rem; font-size: 0.875rem;">
                    For users who prefer not to connect a browser wallet. Enter your token ID or wallet address to look up your NFT.
                </p>

                <div class="form-group">
                    <label for="offline-lookup-type">Lookup by</label>
                    <select id="offline-lookup-type">
                        <option value="tokenId">Token ID</option>
                        <option value="address">Wallet Address</option>
                    </select>
                </div>

                <div class="form-group" id="offline-tokenid-group">
                    <label for="offline-token-id">Token ID</label>
                    <input type="number" id="offline-token-id" placeholder="e.g., 1" min="0">
                </div>

                <div class="form-group hidden" id="offline-address-group">
                    <label for="offline-address">Wallet Address</label>
                    <input type="text" id="offline-address" placeholder="0x...">
                </div>

                <button id="btn-lookup-nft" class="btn-secondary">Lookup NFT</button>
                <div id="offline-lookup-status"></div>

                <div id="offline-nft-info" class="hidden" style="margin-top: 1rem;">
                    <div class="form-group">
                        <label>Message to Sign</label>
                        <div class="code-block" id="offline-public-secret"></div>
                    </div>

                    <div class="form-group">
                        <label>Encrypted Data (hex)</label>
                        <div class="code-block" id="offline-encrypted-data" style="max-height: 100px; overflow-y: auto;"></div>
                    </div>

                    <div class="form-group">
                        <label>CLI Instructions</label>
                        <div class="code-block" id="offline-cli-instructions"></div>
                    </div>

                    <div class="form-group">
                        <label for="offline-signature">Paste Your Signature</label>
                        <textarea id="offline-signature" placeholder="0x..."></textarea>
                    </div>

                    <button id="btn-decrypt-offline">Decrypt Connection Info</button>
                    <div id="decrypt-offline-status"></div>

                    <div id="offline-connection-result" class="hidden" style="margin-top: 1rem;">
                        <label>Connection Details</label>
                        <div class="connection-info" id="offline-connection-info"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Divider -->
        <div class="divider"></div>

        <!-- Send Admin Command Section -->
        <div class="section-title">Send Command</div>
        <p class="section-subtitle">Send encrypted admin commands to the server</p>

        <div class="card" id="admin-command-card">
            <div id="admin-not-connected">
                <p style="color: var(--text-muted); margin-bottom: 1rem; font-size: 0.875rem;">
                    Connect your wallet above to send commands. Only the configured admin wallet can execute commands.
                </p>
            </div>

            <div id="admin-connected" class="hidden">
                <div class="form-group">
                    <label for="command-name">Command Name</label>
                    <input type="text" id="command-name" placeholder="Enter your secret command name">
                    <p style="color: var(--text-muted); font-size: 0.75rem; margin-top: -0.5rem;">
                        The command name is a secret string configured on your server
                    </p>
                </div>

                <div class="form-group">
                    <label for="command-params">Parameters (optional JSON)</label>
                    <textarea id="command-params" placeholder='{ "duration": 300 }'></textarea>
                </div>

                <button id="btn-send-command">Encrypt & Send Command</button>
                <div id="command-status"></div>

                <div id="command-result" class="hidden" style="margin-top: 1rem;">
                    <div class="status success">
                        <p><strong>Command Sent!</strong></p>
                        <p>Transaction: <a id="command-tx-link" class="tx-link" href="#" target="_blank"></a></p>
                        <p style="margin-top: 0.5rem; font-size: 0.875rem;">
                            The server will process this command within the next few blocks.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Ethers.js from CDN (required for wallet interaction) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.9.0/ethers.umd.min.js"></script>

    <!-- Noble secp256k1 for ECIES encryption -->
    <script type="module">
    import { secp256k1 } from 'https://esm.run/@noble/curves@1.4.0/secp256k1';
    import { hkdf } from 'https://esm.run/@noble/hashes@1.4.0/hkdf';
    import { sha256 } from 'https://esm.run/@noble/hashes@1.4.0/sha256';
    import { randomBytes } from 'https://esm.run/@noble/hashes@1.4.0/utils';

    // ECIES encryption implementation using secp256k1
    window.ECIES = {
        hexToBytes(hex) {
            hex = hex.startsWith('0x') ? hex.slice(2) : hex;
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < bytes.length; i++) {
                bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
            }
            return bytes;
        },

        bytesToHex(bytes) {
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        },

        async encrypt(publicKeyHex, plaintext) {
            const serverPubKeyBytes = this.hexToBytes(publicKeyHex);
            const ephemeralPrivKey = randomBytes(32);
            const ephemeralPubKey = secp256k1.getPublicKey(ephemeralPrivKey, false);
            const sharedPoint = secp256k1.getSharedSecret(ephemeralPrivKey, serverPubKeyBytes, false);
            const sharedX = sharedPoint.slice(1, 33);
            const encryptionKey = hkdf(sha256, sharedX, new Uint8Array(0), new Uint8Array(0), 32);
            const iv = randomBytes(12);
            const cryptoKey = await crypto.subtle.importKey('raw', encryptionKey, { name: 'AES-GCM' }, false, ['encrypt']);
            const plaintextBytes = new TextEncoder().encode(plaintext);
            const ciphertextWithTag = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, cryptoKey, plaintextBytes);
            const result = new Uint8Array(ephemeralPubKey.length + iv.length + ciphertextWithTag.byteLength);
            result.set(ephemeralPubKey, 0);
            result.set(iv, ephemeralPubKey.length);
            result.set(new Uint8Array(ciphertextWithTag), ephemeralPubKey.length + iv.length);
            return '0x' + this.bytesToHex(result);
        }
    };

    console.log('ECIES encryption ready');
    window.dispatchEvent(new Event('ecies-ready'));
    </script>

    <script>
    // Configuration (injected by generator)
    const CONFIG = {
        serverPublicKey: '{{SERVER_PUBLIC_KEY}}',
        publicSecret: '{{PUBLIC_SECRET}}',
        chainId: {{CHAIN_ID}},
        rpcUrl: '{{RPC_URL}}',
        nftContract: '{{NFT_CONTRACT}}',
        subscriptionContract: '{{SUBSCRIPTION_CONTRACT}}',
        usdcAddress: '{{USDC_ADDRESS}}',
    };

    // Contract ABIs
    const SUBSCRIPTION_ABI = [
        'function buySubscription(uint256 planId, uint256 days, uint256 paymentMethodId, bytes userEncrypted) external returns (uint256)',
        'function getPlan(uint256 planId) view returns (string name, uint256 pricePerDayUsdCents, bool active)',
        'function getTotalPlanCount() view returns (uint256)',
        'function calculatePayment(uint256 planId, uint256 days, uint256 paymentMethodId) view returns (uint256)',
    ];

    const ERC20_ABI = [
        'function approve(address spender, uint256 amount) external returns (bool)',
        'function allowance(address owner, address spender) view returns (uint256)',
        'function balanceOf(address account) view returns (uint256)',
        'function decimals() view returns (uint8)',
    ];

    const NFT_ABI = [
        'function balanceOf(address owner) view returns (uint256)',
        'function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)',
        'function tokenURI(uint256 tokenId) view returns (string)',
        'function ownerOf(uint256 tokenId) view returns (address)',
    ];

    // Keccak256 implementation (for deriving decryption key from signature)
    function keccak256(input) {
        const RC = [1n, 0x8082n, 0x800000000000808an, 0x8000000080008000n, 0x808bn, 0x80000001n,
            0x8000000080008081n, 0x8000000000008009n, 0x8an, 0x88n, 0x80008009n, 0x8000000an,
            0x8000808bn, 0x800000000000008bn, 0x8000000000008089n, 0x8000000000008003n,
            0x8000000000008002n, 0x8000000000000080n, 0x800an, 0x800000008000000an,
            0x8000000080008081n, 0x8000000000008080n, 0x80000001n, 0x8000000080008008n];
        const ROTC = [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44];
        const PI = [10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20, 14, 22, 9, 6, 1];
        const rotl = (x, n) => ((x << BigInt(n)) | (x >> BigInt(64 - n))) & 0xffffffffffffffffn;

        function keccakF(s) {
            for (let r = 0; r < 24; r++) {
                let c = [0n, 0n, 0n, 0n, 0n];
                for (let x = 0; x < 5; x++) c[x] = s[x] ^ s[x + 5] ^ s[x + 10] ^ s[x + 15] ^ s[x + 20];
                for (let x = 0; x < 5; x++) { let t = c[(x + 4) % 5] ^ rotl(c[(x + 1) % 5], 1); for (let y = 0; y < 25; y += 5) s[x + y] ^= t; }
                let t = s[1]; for (let i = 0; i < 24; i++) { let j = PI[i]; let tmp = s[j]; s[j] = rotl(t, ROTC[i]); t = tmp; }
                for (let y = 0; y < 25; y += 5) { let t0 = s[y], t1 = s[y + 1]; s[y] ^= (~t1) & s[y + 2]; s[y + 1] ^= (~s[y + 2]) & s[y + 3]; s[y + 2] ^= (~s[y + 3]) & s[y + 4]; s[y + 3] ^= (~s[y + 4]) & t0; s[y + 4] ^= (~t0) & t1; }
                s[0] ^= RC[r];
            }
        }

        let msg;
        if (input.startsWith('0x')) {
            input = input.slice(2);
            msg = new Uint8Array(input.length / 2);
            for (let i = 0; i < input.length; i += 2) msg[i / 2] = parseInt(input.substr(i, 2), 16);
        } else {
            msg = new TextEncoder().encode(input);
        }

        const rate = 136;
        let padded = new Uint8Array(Math.ceil((msg.length + 1) / rate) * rate);
        padded.set(msg);
        padded[msg.length] = 0x01;
        padded[padded.length - 1] |= 0x80;

        let s = new Array(25).fill(0n);
        for (let i = 0; i < padded.length; i += rate) {
            for (let j = 0; j < rate / 8; j++) {
                let v = 0n;
                for (let k = 0; k < 8; k++) v |= BigInt(padded[i + j * 8 + k]) << BigInt(k * 8);
                s[j] ^= v;
            }
            keccakF(s);
        }

        let out = new Uint8Array(32);
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 8; j++) {
                out[i * 8 + j] = Number((s[i] >> BigInt(j * 8)) & 0xffn);
            }
        }
        return out;
    }

    // AES-GCM decryption
    async function decryptAesGcm(keyBytes, ciphertextHex) {
        ciphertextHex = ciphertextHex.replace(/^0x/, '');
        const data = new Uint8Array(ciphertextHex.length / 2);
        for (let i = 0; i < ciphertextHex.length; i += 2) data[i / 2] = parseInt(ciphertextHex.substr(i, 2), 16);

        const nonce = data.slice(0, 12);
        const ciphertext = data.slice(12);

        const key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-GCM' }, false, ['decrypt']);
        const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: nonce }, key, ciphertext);
        return new TextDecoder().decode(decrypted);
    }

    // State
    let provider = null;
    let signer = null;
    let userAddress = null;
    let userSignature = null;
    let encryptedSignature = null;
    let plans = [];
    let userNfts = [];
    let selectedNft = null;

    // DOM Elements - Purchase flow
    const btnConnect = document.getElementById('btn-connect');
    const btnSign = document.getElementById('btn-sign');
    const btnPurchase = document.getElementById('btn-purchase');
    const walletNotConnected = document.getElementById('wallet-not-connected');
    const walletConnected = document.getElementById('wallet-connected');
    const walletAddressEl = document.getElementById('wallet-address');
    const daysInput = document.getElementById('days-input');
    const planSelect = document.getElementById('plan-select');
    const totalCostEl = document.getElementById('total-cost');
    const signatureStatus = document.getElementById('signature-status');
    const purchaseStatus = document.getElementById('purchase-status');
    const resultCard = document.getElementById('result-card');

    // Helper: Show status message
    function showStatus(element, message, type = 'info') {
        element.innerHTML = `<div class="status ${type}">${message}</div>`;
    }

    // Helper: Update step indicator
    function updateStep(stepNum, status) {
        const el = document.getElementById(`step${stepNum}-num`);
        el.classList.remove('done', 'error');
        if (status === 'done') {
            el.classList.add('done');
            el.textContent = '✓';
        } else if (status === 'error') {
            el.classList.add('error');
            el.textContent = '!';
        } else {
            el.textContent = stepNum;
        }
    }

    // Tab switching for View My Servers
    window.switchTab = function(tab) {
        document.getElementById('tab-wallet').classList.toggle('active', tab === 'wallet');
        document.getElementById('tab-offline').classList.toggle('active', tab === 'offline');
        document.getElementById('mode-wallet').classList.toggle('hidden', tab !== 'wallet');
        document.getElementById('mode-offline').classList.toggle('hidden', tab !== 'offline');
    };

    // Offline lookup type change
    document.getElementById('offline-lookup-type').addEventListener('change', (e) => {
        document.getElementById('offline-tokenid-group').classList.toggle('hidden', e.target.value !== 'tokenId');
        document.getElementById('offline-address-group').classList.toggle('hidden', e.target.value !== 'address');
    });

    // Load plans from contract
    async function loadPlans() {
        if (!CONFIG.subscriptionContract) {
            console.warn('Subscription contract not configured');
            return;
        }

        try {
            const readProvider = new ethers.JsonRpcProvider(CONFIG.rpcUrl);
            const contract = new ethers.Contract(CONFIG.subscriptionContract, SUBSCRIPTION_ABI, readProvider);
            const totalPlans = await contract.getTotalPlanCount();
            console.log('Total plans:', totalPlans.toString());

            plans = [];
            planSelect.innerHTML = '';

            for (let i = 1; i <= totalPlans; i++) {
                try {
                    const [name, pricePerDayUsdCents, active] = await contract.getPlan(i);
                    if (active) {
                        const pricePerDay = Number(pricePerDayUsdCents) / 100;
                        plans.push({ id: i, name: name, pricePerDay: pricePerDay });
                        const option = document.createElement('option');
                        option.value = i;
                        option.textContent = `${name} - $${pricePerDay.toFixed(2)}/day`;
                        planSelect.appendChild(option);
                    }
                } catch (e) {
                    console.warn(`Error loading plan ${i}:`, e);
                }
            }

            if (plans.length === 0) {
                planSelect.innerHTML = '<option value="">No plans available</option>';
            }
        } catch (err) {
            console.error('Error loading plans:', err);
            planSelect.innerHTML = '<option value="">Error loading plans</option>';
        }
    }

    // Load user's NFTs
    async function loadUserNfts() {
        if (!CONFIG.nftContract || !userAddress) {
            console.warn('NFT contract not configured or wallet not connected');
            return;
        }

        document.getElementById('servers-not-connected').classList.add('hidden');
        document.getElementById('servers-loading').classList.remove('hidden');
        document.getElementById('servers-list').classList.add('hidden');
        document.getElementById('servers-empty').classList.add('hidden');
        document.getElementById('servers-decrypt').classList.add('hidden');
        document.getElementById('connection-result').classList.add('hidden');

        try {
            const readProvider = new ethers.JsonRpcProvider(CONFIG.rpcUrl);
            const nftContract = new ethers.Contract(CONFIG.nftContract, NFT_ABI, readProvider);

            const balance = await nftContract.balanceOf(userAddress);
            console.log('NFT balance:', balance.toString());

            userNfts = [];
            for (let i = 0; i < balance; i++) {
                try {
                    const tokenId = await nftContract.tokenOfOwnerByIndex(userAddress, i);
                    const tokenURI = await nftContract.tokenURI(tokenId);
                    const metadata = await fetchTokenMetadata(tokenURI);
                    userNfts.push({ tokenId: tokenId.toString(), metadata });
                } catch (e) {
                    console.warn(`Error loading token at index ${i}:`, e);
                }
            }

            document.getElementById('servers-loading').classList.add('hidden');

            if (userNfts.length === 0) {
                document.getElementById('servers-empty').classList.remove('hidden');
            } else {
                renderNftList();
                document.getElementById('servers-list').classList.remove('hidden');
            }
        } catch (err) {
            console.error('Error loading NFTs:', err);
            document.getElementById('servers-loading').classList.add('hidden');
            document.getElementById('servers-empty').classList.remove('hidden');
        }
    }

    // Fetch token metadata from URI
    async function fetchTokenMetadata(tokenURI) {
        try {
            // Handle data URIs
            if (tokenURI.startsWith('data:application/json')) {
                const json = tokenURI.replace('data:application/json;base64,', '');
                return JSON.parse(atob(json));
            }
            // Handle IPFS
            if (tokenURI.startsWith('ipfs://')) {
                tokenURI = tokenURI.replace('ipfs://', 'https://ipfs.io/ipfs/');
            }
            const response = await fetch(tokenURI);
            return await response.json();
        } catch (e) {
            console.error('Error fetching metadata:', e);
            return { name: 'Unknown', description: 'Could not load metadata' };
        }
    }

    // Render NFT list
    function renderNftList() {
        const container = document.getElementById('servers-list');
        container.innerHTML = '';

        userNfts.forEach((nft, index) => {
            const card = document.createElement('div');
            card.className = 'server-card' + (index === 0 ? ' selected' : '');
            card.innerHTML = `
                <div class="server-card-header">
                    <span class="server-card-title">${nft.metadata.name || 'Server'}</span>
                    <span class="server-card-id">Token #${nft.tokenId}</span>
                </div>
                <div style="color: var(--text-muted); font-size: 0.75rem;">
                    ${nft.metadata.description || ''}
                </div>
            `;
            card.onclick = () => selectNft(index);
            container.appendChild(card);
        });

        if (userNfts.length > 0) {
            selectNft(0);
        }
    }

    // Select an NFT
    function selectNft(index) {
        selectedNft = userNfts[index];
        document.querySelectorAll('.server-card').forEach((card, i) => {
            card.classList.toggle('selected', i === index);
        });
        document.getElementById('servers-decrypt').classList.remove('hidden');
        document.getElementById('connection-result').classList.add('hidden');
        document.getElementById('decrypt-wallet-status').innerHTML = '';
    }

    // Decrypt NFT connection info (wallet mode)
    document.getElementById('btn-decrypt-wallet').addEventListener('click', async () => {
        if (!selectedNft || !signer) return;

        const btn = document.getElementById('btn-decrypt-wallet');
        const statusEl = document.getElementById('decrypt-wallet-status');

        try {
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span>Signing...';

            // Get public secret from NFT metadata (may be at top level or nested under 'access')
            const access = selectedNft.metadata.access || {};
            const publicSecret = selectedNft.metadata.publicSecret || selectedNft.metadata.public_secret || access.publicSecret || access.public_secret || CONFIG.publicSecret;
            const userEncrypted = selectedNft.metadata.userEncrypted || selectedNft.metadata.user_encrypted || access.userEncrypted || access.user_encrypted;

            if (!userEncrypted) {
                throw new Error('No encrypted data found in NFT metadata');
            }

            // Sign the public secret
            const signature = await signer.signMessage(publicSecret);

            // Derive key from signature
            showStatus(statusEl, 'Decrypting...', 'info');
            const keyBytes = keccak256(signature);

            // Decrypt
            const decrypted = await decryptAesGcm(keyBytes, userEncrypted);

            // Show result
            document.getElementById('connection-info').textContent = decrypted;
            document.getElementById('connection-result').classList.remove('hidden');
            statusEl.innerHTML = '';

        } catch (err) {
            console.error('Decrypt error:', err);
            showStatus(statusEl, err.message || 'Decryption failed', 'error');
        } finally {
            btn.disabled = false;
            btn.textContent = 'Sign to Decrypt Connection Info';
        }
    });

    // Lookup NFT (offline mode)
    document.getElementById('btn-lookup-nft').addEventListener('click', async () => {
        const lookupType = document.getElementById('offline-lookup-type').value;
        const statusEl = document.getElementById('offline-lookup-status');

        if (!CONFIG.nftContract) {
            showStatus(statusEl, 'NFT contract not configured', 'error');
            return;
        }

        try {
            const readProvider = new ethers.JsonRpcProvider(CONFIG.rpcUrl);
            const nftContract = new ethers.Contract(CONFIG.nftContract, NFT_ABI, readProvider);

            let tokenId;
            if (lookupType === 'tokenId') {
                tokenId = document.getElementById('offline-token-id').value;
                if (!tokenId) {
                    throw new Error('Please enter a token ID');
                }
            } else {
                const address = document.getElementById('offline-address').value;
                if (!address || !ethers.isAddress(address)) {
                    throw new Error('Please enter a valid wallet address');
                }
                const balance = await nftContract.balanceOf(address);
                if (balance === 0n) {
                    throw new Error('No NFTs found for this address');
                }
                tokenId = await nftContract.tokenOfOwnerByIndex(address, 0);
            }

            showStatus(statusEl, 'Loading NFT metadata...', 'info');

            const tokenURI = await nftContract.tokenURI(tokenId);
            const metadata = await fetchTokenMetadata(tokenURI);

            // May be at top level or nested under 'access'
            const access = metadata.access || {};
            const publicSecret = metadata.publicSecret || metadata.public_secret || access.publicSecret || access.public_secret || CONFIG.publicSecret;
            const userEncrypted = metadata.userEncrypted || metadata.user_encrypted || access.userEncrypted || access.user_encrypted;

            if (!userEncrypted) {
                throw new Error('No encrypted data found in NFT metadata');
            }

            // Display info for offline signing
            document.getElementById('offline-public-secret').textContent = publicSecret;
            document.getElementById('offline-encrypted-data').textContent = userEncrypted;
            document.getElementById('offline-cli-instructions').textContent =
`# Sign with cast (Foundry)
cast wallet sign "${publicSecret}" --private-key YOUR_PRIVATE_KEY

# Or with ethers.js
const wallet = new ethers.Wallet('YOUR_PRIVATE_KEY');
console.log(await wallet.signMessage('${publicSecret}'));`;

            document.getElementById('offline-nft-info').classList.remove('hidden');
            document.getElementById('offline-connection-result').classList.add('hidden');
            statusEl.innerHTML = '';

            // Store for later decryption
            window.offlineNftData = { publicSecret, userEncrypted };

        } catch (err) {
            console.error('Lookup error:', err);
            showStatus(statusEl, err.message || 'Lookup failed', 'error');
        }
    });

    // Decrypt (offline mode)
    document.getElementById('btn-decrypt-offline').addEventListener('click', async () => {
        const statusEl = document.getElementById('decrypt-offline-status');
        const signature = document.getElementById('offline-signature').value.trim();

        if (!signature) {
            showStatus(statusEl, 'Please paste your signature', 'error');
            return;
        }

        if (!window.offlineNftData) {
            showStatus(statusEl, 'Please lookup an NFT first', 'error');
            return;
        }

        try {
            showStatus(statusEl, 'Decrypting...', 'info');

            const keyBytes = keccak256(signature);
            const decrypted = await decryptAesGcm(keyBytes, window.offlineNftData.userEncrypted);

            document.getElementById('offline-connection-info').textContent = decrypted;
            document.getElementById('offline-connection-result').classList.remove('hidden');
            statusEl.innerHTML = '';

        } catch (err) {
            console.error('Decrypt error:', err);
            showStatus(statusEl, 'Decryption failed. Make sure you signed the correct message with the correct key.', 'error');
        }
    });

    // Step 1: Connect Wallet
    btnConnect.addEventListener('click', async () => {
        try {
            btnConnect.disabled = true;
            btnConnect.innerHTML = '<span class="spinner"></span>Connecting...';

            if (!window.ethereum) {
                throw new Error('No wallet found. Please install MetaMask.');
            }

            provider = new ethers.BrowserProvider(window.ethereum);
            await provider.send('eth_requestAccounts', []);
            signer = await provider.getSigner();
            userAddress = await signer.getAddress();

            const network = await provider.getNetwork();
            if (Number(network.chainId) !== CONFIG.chainId) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: '0x' + CONFIG.chainId.toString(16) }],
                    });
                    provider = new ethers.BrowserProvider(window.ethereum);
                    signer = await provider.getSigner();
                } catch (e) {
                    throw new Error(`Please switch to chain ID ${CONFIG.chainId}`);
                }
            }

            walletNotConnected.classList.add('hidden');
            walletConnected.classList.remove('hidden');
            walletAddressEl.textContent = userAddress;
            updateStep(1, 'done');
            btnSign.disabled = false;

            // Load user's NFTs for View My Servers
            loadUserNfts();

            // Show admin command section
            document.getElementById('admin-not-connected').classList.add('hidden');
            document.getElementById('admin-connected').classList.remove('hidden');

        } catch (err) {
            showStatus(signatureStatus, err.message, 'error');
            updateStep(1, 'error');
            btnConnect.disabled = false;
            btnConnect.textContent = 'Connect Wallet';
        }
    });

    // Step 2: Sign Message
    btnSign.addEventListener('click', async () => {
        try {
            btnSign.disabled = true;
            btnSign.innerHTML = '<span class="spinner"></span>Waiting for signature...';

            if (!window.ECIES) {
                await new Promise(resolve => {
                    window.addEventListener('ecies-ready', resolve, { once: true });
                });
            }

            userSignature = await signer.signMessage(CONFIG.publicSecret);
            showStatus(signatureStatus, 'Encrypting credentials...', 'info');
            encryptedSignature = await window.ECIES.encrypt(CONFIG.serverPublicKey, userSignature);

            showStatus(signatureStatus, 'Authentication complete!', 'success');
            updateStep(2, 'done');

            planSelect.disabled = false;
            daysInput.disabled = false;
            btnPurchase.disabled = false;
            updateCost();

        } catch (err) {
            console.error('Sign error:', err);
            showStatus(signatureStatus, err.message, 'error');
            updateStep(2, 'error');
            btnSign.disabled = false;
            btnSign.textContent = 'Sign Authentication';
        }
    });

    // Update cost calculation
    async function updateCost() {
        const planId = parseInt(planSelect.value);
        const days = parseInt(daysInput.value) || 30;
        const plan = plans.find(p => p.id === planId);
        if (plan) {
            const total = days * plan.pricePerDay;
            totalCostEl.textContent = `$${total.toFixed(2)} USDC`;
        } else {
            totalCostEl.textContent = '-';
        }
    }

    daysInput.addEventListener('input', updateCost);
    planSelect.addEventListener('change', updateCost);

    // Step 3: Purchase
    btnPurchase.addEventListener('click', async () => {
        try {
            btnPurchase.disabled = true;
            btnPurchase.innerHTML = '<span class="spinner"></span>Processing...';

            const planId = parseInt(planSelect.value);
            const days = parseInt(daysInput.value);

            if (!CONFIG.subscriptionContract || !CONFIG.usdcAddress) {
                throw new Error('Contract addresses not configured');
            }

            if (!planId || planId < 1) {
                throw new Error('Please select a plan');
            }

            const subscriptionContract = new ethers.Contract(CONFIG.subscriptionContract, SUBSCRIPTION_ABI, signer);
            const usdc = new ethers.Contract(CONFIG.usdcAddress, ERC20_ABI, signer);

            showStatus(purchaseStatus, 'Calculating payment...', 'info');
            const paymentAmount = await subscriptionContract.calculatePayment(planId, days, 1);

            const balance = await usdc.balanceOf(userAddress);
            if (balance < paymentAmount) {
                throw new Error(`Insufficient USDC balance. Need ${ethers.formatUnits(paymentAmount, 6)} USDC`);
            }

            const allowance = await usdc.allowance(userAddress, CONFIG.subscriptionContract);
            if (allowance < paymentAmount) {
                showStatus(purchaseStatus, 'Approving USDC spend...', 'info');
                const approveTx = await usdc.approve(CONFIG.subscriptionContract, paymentAmount);
                await approveTx.wait();
            }

            showStatus(purchaseStatus, 'Confirm transaction in wallet...', 'info');
            const tx = await subscriptionContract.buySubscription(planId, days, 1, encryptedSignature);

            showStatus(purchaseStatus, 'Transaction submitted, waiting for confirmation...', 'info');
            const receipt = await tx.wait();

            updateStep(3, 'done');
            document.getElementById('step3').classList.add('hidden');
            resultCard.classList.remove('hidden');

            const txLink = document.getElementById('tx-link');
            txLink.href = `https://sepolia.etherscan.io/tx/${receipt.hash}`;
            txLink.textContent = receipt.hash.slice(0, 10) + '...' + receipt.hash.slice(-8);

        } catch (err) {
            console.error(err);
            showStatus(purchaseStatus, err.message || 'Transaction failed', 'error');
            updateStep(3, 'error');
            btnPurchase.disabled = false;
            btnPurchase.textContent = 'Purchase Subscription';
        }
    });

    // Admin Command: Send encrypted command
    document.getElementById('btn-send-command').addEventListener('click', async () => {
        const btn = document.getElementById('btn-send-command');
        const statusEl = document.getElementById('command-status');
        const resultEl = document.getElementById('command-result');

        const commandName = document.getElementById('command-name').value.trim();
        const paramsText = document.getElementById('command-params').value.trim();

        if (!commandName) {
            showStatus(statusEl, 'Please enter a command name', 'error');
            return;
        }

        if (!signer) {
            showStatus(statusEl, 'Please connect your wallet first', 'error');
            return;
        }

        try {
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span>Preparing...';

            // Parse params if provided
            let params = {};
            if (paramsText) {
                try {
                    params = JSON.parse(paramsText);
                } catch (e) {
                    throw new Error('Invalid JSON in parameters');
                }
            }

            // Build command with nonce and timestamp
            const command = {
                command: commandName,
                params: params,
                nonce: crypto.randomUUID(),
                timestamp: Math.floor(Date.now() / 1000)
            };

            showStatus(statusEl, 'Encrypting command...', 'info');

            // Wait for ECIES to be ready
            if (!window.ECIES) {
                await new Promise(resolve => {
                    window.addEventListener('ecies-ready', resolve, { once: true });
                });
            }

            // Encrypt with server's public key (ECIES)
            const plaintext = JSON.stringify(command);
            const ciphertext = await window.ECIES.encrypt(CONFIG.serverPublicKey, plaintext);

            showStatus(statusEl, 'Confirm transaction in wallet...', 'info');

            // Build and send transaction
            // Send to self (tx.from === tx.to) which works with 'self' destination mode
            const tx = await signer.sendTransaction({
                to: userAddress,
                data: ciphertext,
                value: 0
            });

            showStatus(statusEl, 'Transaction submitted, waiting for confirmation...', 'info');

            const receipt = await tx.wait();

            // Show success
            statusEl.innerHTML = '';
            resultEl.classList.remove('hidden');
            const txLink = document.getElementById('command-tx-link');
            txLink.href = `https://sepolia.etherscan.io/tx/${receipt.hash}`;
            txLink.textContent = receipt.hash.slice(0, 10) + '...' + receipt.hash.slice(-8);

            // Clear form
            document.getElementById('command-name').value = '';
            document.getElementById('command-params').value = '';

        } catch (err) {
            console.error('Command error:', err);
            showStatus(statusEl, err.message || 'Failed to send command', 'error');
        } finally {
            btn.disabled = false;
            btn.textContent = 'Encrypt & Send Command';
        }
    });

    // Initialize
    console.log('Blockhost Signup Page loaded');
    console.log('Config:', {
        ...CONFIG,
        serverPublicKey: CONFIG.serverPublicKey ? CONFIG.serverPublicKey.slice(0, 20) + '...' : 'NOT SET'
    });

    loadPlans();
    </script>
</body>
</html>
